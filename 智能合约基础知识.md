# 智能合约基础知识

## 智能合约介绍

智能合约（Smart contract ）是一种旨在以信息化方式传播、验证或执行合同的计算机协议。智能合约允许在没有第三方的情况下进行可信交易，这些交易可追踪且不可逆转。智能合约概念于1995年由Nick Szabo首次提出。

智能合约的目的是提供优于传统合约的安全方法，并减少与合约相关的其他交易成本。

简单地说，智能合约可以理解为一个自执行的协议。智能合约可以自动处理协议的履行、管理、以及支付。

## Solidity介绍

Solidity语言是一种面向智能合约，基于以太坊虚拟机（EVM）运行的高级编程语言。

Solidity语法深受C++、Python和JavaScript影响。

Solidity是静态类型语言，支持继承、库和复杂类型定义等功能。

Solidity一般用于在区块链上运行投票、众筹、拍卖和钱包等业务场景的智能合约。

## 以太坊虚拟机介绍

以太坊虚拟机（Ethereum Virtual Machine），简称EVM，是以太坊中智能合约的运行环境。

以太坊虚拟机不仅是一个完全独立的沙盒，而且合约代码对外完全隔离，EVM中的代码无法接触到网络、文件系统和其他进程，智能合约对于其他智能合约的访问也是非常有限的。同时以太坊虚拟机又能与主网的其余部分隔离，运行时不影响主区块链的操作。

### 账户

以太坊中有两种账户：外部账户和合约账户，它们共享同一地址空间。外部账户是由公私钥对控制的账户(可以理解为人控制的账户)，合约账户由代码所控制。

外部帐户的地址是从公钥确定的，而合约地址是在合约创建时确定的（它是从创建者地址和从该地址发送的事务数派生的，即所谓的“nonce”）。EVM对待两种账户的方式是相同的。

每个账户都有一个键值对存储，能够映射256位的字符到256位的字符，称为存储(storage)。每个账户还会有余额(balance),以"wei"为单位，一个以太币是10的18次方wei。

### 交易

交易是从一个帐户发送到另一个帐户的消息（可能相同或为空），包含二进制数据（称为“有效载荷”）和 Ether 。

如果目标帐户包含代码，则执行该代码，并将有有效载荷作为输入数据提供。

如果未设置目标帐户（事务没有收件人或收件人设置为 `null` ），交易会创建一个新合约。像上文中提到的那样，该合约的地址不是零地址，而是由"nonce"值来决定。此时交易中的负载被编译成EVM字节码并执行。输出的代码作为智能合约的代码被永久存储到合约中。这也就意味着，你不需要发送合约的实际代码，只需要发送能返回合约代码的代码，就能够创建智能合约。

但在本课程中，我们不会涉及到其中的细节，还是以学习智能合约的实际代码为主。

### Gas

合约创建完成后，每个交易被给与了一定数额的gas，用来限制执行交易的代码的工作量，同时对执行过程进行支付。当EVM执行合约时，gas会逐渐被消耗。

gas price是合约创建者设定的一个值，他会支付gas * gas price的值，如果执行后还剩下一些gas，则以相同的方式将其退还给创建者。

如果在任何时候用尽了gas（即为负），则会触发“gas不足”异常，该异常将还原对当前调用帧中的状态所做的所有修改。

### 存储，内存和栈

EVM中有三个地方能够存储数据：存储，内存和栈，下面将进行详细的介绍。

每个帐户都有一个称为存储的数据区域，该区域在函数调用和消息之间保持不变。存储是将256位映射到256位的键值存储。从合同中枚举存储是不可能的，读取相对代价较高，甚至初始化和修改存储的成本也更高。因此，应该将存储的内容尽量最小化。 如派生的计算，缓存和聚合等应当存储在合约之外。 合约无法读取或写入除其自身之外的任何存储。

第二个数据区域称为内存，合同为每个消息调用获取一个新近清除的实例。 内存是线性的，可以在字节级别寻址，读取的宽度限制为256位，而写入的宽度可以为8位或256位。 当访问（读取或写入）先前未触及的存储字（即，一个字内的任何偏移量）时，内存将由256位扩展。 在扩建时，必须支付天然气成本。 内存越大，内存的成本就越高（它会逐渐增加）。

EVM不是寄存器机，而是堆栈机，因此所有计算都在称为堆栈的数据区域上执行。它的最大大小为1024个元素，由256位字构成。 EVM中的堆栈支持一下操作：将最上面的16个元素之一复制到堆栈的顶部，或者将最上面的元素与下面的16个元素之一交换。所有其他操作都从堆栈中获取最上面的一个或多个（取决于不同的操作）元素，并将结果压入堆栈。当然，可以将堆栈元素移动到存储器或内存中，以便更深地访问堆栈，但是，如果不先移除堆栈顶部，就不能仅访问堆栈中更深的任意元素。

### 指令集

EVM的指令集保持最少，以避免可能导致共识问题的错误或不一致的实现。 所有指令都是对基本数据类型，256位字或内存切片（或其他字节数组）进行操作。指令集中包含常见的算术，位，逻辑和比较操作，也支持有条件和无条件的跳转。此外，合约可以访问当前块的相关属性，例如其编号和时间戳。

这里我们不对指令集做过多介绍，有兴趣的同学可以自行了解。

### 消息调用

合约可以通过消息调用的方式调用其他合约，或者发送以太币到非合约账户。消息调用和交易类似，都具有发送者，接收者，负载，以太币，gas和返回数据。实际上，每个交易都包含一个顶级的消息调用，该消息调用可以创建其他的消息调用。

合同可以通过内部消息调用发送多少剩余气体，以及希望保留多少。如果内部调用（或任何其他异常）中发生了gas不足异常或其他异常，则将通过将错误值放入堆栈来进行表示。在这种情况下，只有随调用一起发送的gas会被用完。并且，Solidity中，发起调用的合约默认会触发一个手工的异常，以便异常可以从调用栈里“冒泡出来”。

如前所述，被调用合约（可以与调用者相同）将接收到一个新近清除的内存实例，并可以访问调用的负载——由被称为 calldata 的独立区域所提供的数据。执行完毕后，它可以返回数据，该数据将存储在呼叫者预先分配的呼叫者内存中的某个位置。 所有这些调用都是完全同步的。

调用执行结束后，返回数据将被存放在调用方预先分配好的一块内存中。 调用深度被限制为 1024 ，因此对于更加复杂的操作，我们应使用循环而不是递归。

### 委托调用和库

有一种特殊类型的消息调用，被称为委托调用(delegate call) 。它和一般的消息调用的区别在于，目标地址的代码将在发起调用的合约的上下文中执行，并且 `msg.sender` 和 `msg.value` 不变。 这意味着一个合约可以在运行时从另外一个地址动态加载代码。存储、当前地址和余额都指向发起调用的合约，只有代码是从被调用地址获取的。 这使得 Solidity 可以实现”库“能力：可复用的代码库可以放在一个合约的存储上，如用来实现复杂的数据结构的库。

### 日志

日志（logs）是一种特殊的可索引数据结构，其存储的数据可以一直映射到区块层级。Solidity用它来实现事件(events) 。合约创建之后就无法访问日志数据，但是这些数据可以从区块链外部进行有效访问。因为部分日志数据被存储在 布隆过滤器（Bloom filter）中，我们可以高效并且加密安全地搜索日志，那些没有下载整个区块链的网络节点（轻客户端）也可以找到这些日志。

### 合约创建

合约甚至可以通过一个特殊的指令来创建其他合约（不是简单的调用零地址）。创建合约的调用和普通消息调用的唯一区别在于，负载会被执行，执行的结果被存储为合约代码，调用者/创建者在栈上得到新合约的地址。

### 失效和自毁

合约代码从区块链上移除的唯一方式是合约在合约地址上执行自毁操作 `selfdestruct` 。合约账户上剩余的以太币会发送给指定的目标，然后其存储和代码从状态中被移除。移除合约有很大的潜在危险，如果有人发送以太币到移除的合约，这些以太币将永远丢失。

如果要使合同失效，则应通过更改内部状态来禁用合约，这样可以在使函数无法执行从而进行撤回，从而达到立刻返还以太币的目的。